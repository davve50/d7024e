
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>d7024e: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">kademlia/d7024e/bucket.go (100.0%)</option>
				
				<option value="file1">kademlia/d7024e/cli.go (100.0%)</option>
				
				<option value="file2">kademlia/d7024e/contact.go (100.0%)</option>
				
				<option value="file3">kademlia/d7024e/kademlia.go (54.1%)</option>
				
				<option value="file4">kademlia/d7024e/kademliaid.go (100.0%)</option>
				
				<option value="file5">kademlia/d7024e/network.go (40.5%)</option>
				
				<option value="file6">kademlia/d7024e/routingtable.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package d7024e

import (
        "container/list"
)

// bucket definition
// contains a List
type bucket struct {
        list *list.List
}

// newBucket returns a new instance of a bucket
func newBucket() *bucket <span class="cov8" title="1">{
        bucket := &amp;bucket{}
        bucket.list = list.New()
        return bucket
}</span>

// AddContact adds the Contact to the front of the bucket
// or moves it to the front of the bucket if it already existed
func (bucket *bucket) AddContact(contact Contact) <span class="cov8" title="1">{
        var element *list.Element
        for e := bucket.list.Front(); e != nil; e = e.Next() </span><span class="cov8" title="1">{
                nodeID := e.Value.(Contact).ID

                if (contact).ID.Equals(nodeID) </span><span class="cov8" title="1">{
                        element = e
                }</span>
        }

        <span class="cov8" title="1">if element == nil </span><span class="cov8" title="1">{
                if bucket.list.Len() &lt; bucketSize </span><span class="cov8" title="1">{
                        bucket.list.PushFront(contact)
                }</span>
        } else<span class="cov8" title="1"> {
                bucket.list.MoveToFront(element)
        }</span>
}

// GetContactAndCalcDistance returns an array of Contacts where 
// the distance has already been calculated
func (bucket *bucket) GetContactAndCalcDistance(target *KademliaID) []Contact <span class="cov8" title="1">{
        var contacts []Contact

        for elt := bucket.list.Front(); elt != nil; elt = elt.Next() </span><span class="cov8" title="1">{
                contact := elt.Value.(Contact)
                contact.CalcDistance(target)
                contacts = append(contacts, contact)
        }</span>

        <span class="cov8" title="1">return contacts</span>
}

// Len return the size of the bucket
func (bucket *bucket) Len() int <span class="cov8" title="1">{
        return bucket.list.Len()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package d7024e

import (
        "bufio"
        "fmt"
        "strings"
)

func (kad *Kademlia) CLI(scanner *bufio.Scanner) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                fmt.Print("Enter a command: ")
                //scanner := bufio.NewScanner(reader)
                scanner.Scan()
                cmd := scanner.Text()
                //fmt.Print("Running command: ", cmd)

                switch </span>{
                case strings.Contains(cmd, "put "):<span class="cov8" title="1">
                        fmt.Println(kad.hash)
                        hash := cmd[4:]
                        kad.Store([]byte(hash)) // Mayb not correct?
                        fmt.Println(kad.hash)</span>
                case strings.Contains(cmd, "get "):<span class="cov8" title="1">
                        hash := cmd[4:]
                        if len(hash) != IDLength*2 </span><span class="cov8" title="1">{
                                fmt.Println("Wrong input")
                                break</span>
                        }
                        <span class="cov8" title="1">value := ""
                        contacts := make([]Contact, 0)
                        kad.LookupData(hash, &amp;value, &amp;contacts)
                        fmt.Println("[CLI] Value:", value)
                        fmt.Println("[CLI] Contacts:", contacts)</span>
                case strings.Contains(cmd, "exit"):<span class="cov8" title="1">
                        //Exit here some otherway
                        return</span>
                        //os.Exit(0)
                default:<span class="cov8" title="1">
                        fmt.Println("Error: Wrong command.")</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package d7024e

import (
        "fmt"
        "sort"
)

// Contact definition
// stores the KademliaID, the ip address and the distance
type Contact struct {
        ID       *KademliaID
        Address  string
        distance *KademliaID
}

// NewContact returns a new instance of a Contact
func NewContact(id *KademliaID, address string) Contact <span class="cov8" title="1">{
        return Contact{id, address, nil}
}</span>

// CalcDistance calculates the distance to the target and 
// fills the contacts distance field
func (contact *Contact) CalcDistance(target *KademliaID) <span class="cov8" title="1">{
        contact.distance = contact.ID.CalcDistance(target)
}</span>

// Less returns true if contact.distance &lt; otherContact.distance
func (contact *Contact) Less(otherContact *Contact) bool <span class="cov8" title="1">{
        return contact.distance.Less(otherContact.distance)
}</span>

// String returns a simple string representation of a Contact
func (contact *Contact) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(`contact("%s", "%s")`, contact.ID, contact.Address)
}</span>

// ContactCandidates definition
// stores an array of Contacts
type ContactCandidates struct {
        contacts []Contact
}

// Append an array of Contacts to the ContactCandidates
func (candidates *ContactCandidates) Append(contacts []Contact) <span class="cov8" title="1">{
        candidates.contacts = append(candidates.contacts, contacts...)
}</span>

// GetContacts returns the first count number of Contacts
func (candidates *ContactCandidates) GetContacts(count int) []Contact <span class="cov8" title="1">{
        return candidates.contacts[:count]
}</span>

// Sort the Contacts in ContactCandidates
func (candidates *ContactCandidates) Sort() <span class="cov8" title="1">{
        sort.Sort(candidates)
}</span>

// Len returns the length of the ContactCandidates
func (candidates *ContactCandidates) Len() int <span class="cov8" title="1">{
        return len(candidates.contacts)
}</span>

// Swap the position of the Contacts at i and j
// WARNING does not check if either i or j is within range
func (candidates *ContactCandidates) Swap(i, j int) <span class="cov8" title="1">{
        candidates.contacts[i], candidates.contacts[j] = candidates.contacts[j], candidates.contacts[i]
}</span>

// Less returns true if the Contact at index i is smaller than 
// the Contact at index j
func (candidates *ContactCandidates) Less(i, j int) bool <span class="cov8" title="1">{
        return candidates.contacts[i].Less(&amp;candidates.contacts[j])
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package d7024e

import "fmt"

type Kademlia struct {
        network    *Network
        routingtab *RoutingTable
        hash       map[string][]byte
}

func InitKademlia(me Contact) *Kademlia <span class="cov8" title="1">{
        newKademlia := &amp;Kademlia{
                routingtab: NewRoutingTable(me),
                hash:       make(map[string][]byte),
        }
        return newKademlia
}</span>

type VisitList struct {
        list    []Contact
        visited map[Contact]bool
}

var alpha int = 3

func (kademlia *Kademlia) setNetwork(network *Network) <span class="cov8" title="1">{
        kademlia.network = network
}</span>

func (kademlia *Kademlia) LookupContact(target Contact, contacts *[]Contact) <span class="cov8" title="1">{
        nodesToCheck := 0

        var closest Contact
        alphaClosest := kademlia.routingtab.FindClosestContacts(target.ID, alpha)
        if len(alphaClosest) != 0 </span><span class="cov8" title="1">{
                closest = alphaClosest[0]
        }</span>

        <span class="cov8" title="1">results := make([]Contact, 0)

        vl := &amp;VisitList{ // Checks if SendFindNodePacket for that node has been called
                list:    make([]Contact, 0),
                visited: make(map[Contact]bool),
        }

        resVl := make(map[Contact]bool) // Checks if node has been added to visitList

        // checking my alpha closest nodes
        for _, node := range alphaClosest </span><span class="cov8" title="1">{
                vl.list = append(vl.list, node)
                resVl[node] = true
        }</span>

        // getting contacts from my alpha closest nodes
        <span class="cov8" title="1">for nodesToCheck &lt; len(vl.list) </span><span class="cov8" title="1">{
                kademlia.network.SendFindNodePacket(&amp;vl.list[nodesToCheck], &amp;target, &amp;results)

                vl.visited[vl.list[nodesToCheck]] = true
                nodesToCheck++
        }</span>

        // Loop through the nodes we need to check to find the shortest path
        <span class="cov8" title="1">for nodesToCheck &gt; 0 </span><span class="cov8" title="1">{
                // Loop through and check if any of the found contacts are not added to the list of to be checked
                for _, node := range results </span><span class="cov0" title="0">{
                        if (node.Address != kademlia.network.me.Address) &amp;&amp; (node.ID != nil) </span><span class="cov0" title="0">{
                                if !resVl[node] </span><span class="cov0" title="0">{
                                        resVl[node] = true
                                        node.CalcDistance(kademlia.network.me.ID)
                                        vl.list = append(vl.list, node)
                                }</span>
                        }
                }

                // Sort the list by lowest distance
                <span class="cov8" title="1">vl.list = iSort(vl.list, &amp;target)
                nodesToCheck--

                // If there is a new closest node to the target we need to check the alpha closest nodes
                if closest.ID.String() != vl.list[0].ID.String() </span><span class="cov0" title="0">{
                        closest = vl.list[0]
                        for i, node := range vl.list </span><span class="cov0" title="0">{
                                if i &gt;= alpha </span><span class="cov0" title="0">{
                                        break</span>
                                }

                                <span class="cov0" title="0">if !vl.visited[node] </span><span class="cov0" title="0">{
                                        kademlia.network.SendFindNodePacket(&amp;node, &amp;target, &amp;results)

                                        vl.visited[node] = true
                                        nodesToCheck++
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">fmt.Println("[LookupContact] Checking if every node has been visited:")
        for _, node := range vl.list </span><span class="cov8" title="1">{
                fmt.Printf("\t%s = %t\n", node.ID.String(), vl.visited[node])
        }</span>

        <span class="cov8" title="1">if len(vl.list) &gt; bucketSize </span><span class="cov0" title="0">{
                *contacts = vl.list[:bucketSize]
        }</span> else<span class="cov8" title="1"> {
                *contacts = vl.list
        }</span>
}

func (kademlia *Kademlia) LookupData(hash string, value *string, contacts *[]Contact) <span class="cov8" title="1">{
        nodesToCheck := 0

        // We store results from SendFindValuePacket in these
        resultContacts := make([]Contact, 0)
        resultHash := ""
        var closest Contact

        target := NewContact(NewKademliaID(hash), "")
        alphaClosest := kademlia.routingtab.FindClosestContacts(target.ID, alpha)
        if len(alphaClosest) != 0 </span><span class="cov0" title="0">{
                closest = alphaClosest[0]
        }</span>

        <span class="cov8" title="1">noValueList := make([]Contact, 0)

        vl := &amp;VisitList{ // Checks if SendFindValuePacket for that node has been called
                list:    make([]Contact, 0),
                visited: make(map[Contact]bool),
        }

        resVl := make(map[Contact]bool) // Checks if node has been added to visitList

        // checking my alpha closest nodes
        for _, node := range alphaClosest </span><span class="cov0" title="0">{
                vl.list = append(vl.list, node)
                resVl[node] = true
        }</span>

        //Check alpha closests nodes if someone knows value
        <span class="cov8" title="1">for nodesToCheck &lt; len(vl.list) </span><span class="cov0" title="0">{
                nodesToCheck++
                kademlia.network.SendFindValuePacket(&amp;vl.list[nodesToCheck], hash, &amp;resultContacts, &amp;resultHash)
                // If we found a value
                if resultHash != "" </span><span class="cov0" title="0">{
                        if len(noValueList) != 0 </span><span class="cov0" title="0">{
                                fmt.Println("Stored in closest node")
                                kademlia.network.SendStorePacket(&amp;noValueList[0], []byte(resultHash))
                        }</span>
                        <span class="cov0" title="0">*value = resultHash
                        return</span>
                }
                <span class="cov0" title="0">for _, node := range resultContacts </span><span class="cov0" title="0">{
                        if (node.Address != kademlia.network.me.Address) &amp;&amp; (node.ID != nil) </span><span class="cov0" title="0">{
                                node.CalcDistance(kademlia.network.me.ID)
                                noValueList = append(noValueList, node)
                        }</span>
                        <span class="cov0" title="0">noValueList = iSort(noValueList, &amp;target)</span>
                }
        }

        // No value found, but up to alpha*k new contacts to ask.

        <span class="cov8" title="1">for nodesToCheck &gt; 0 </span><span class="cov0" title="0">{
                // Loop through and check if any of the found contacts are not added to the list of to be checked
                for _, node := range resultContacts </span><span class="cov0" title="0">{
                        if (node.Address != kademlia.network.me.Address) &amp;&amp; (node.ID != nil) </span><span class="cov0" title="0">{
                                if !resVl[node] </span><span class="cov0" title="0">{
                                        resVl[node] = true
                                        node.CalcDistance(kademlia.network.me.ID)
                                        vl.list = append(vl.list, node)
                                }</span>
                        }
                }

                // Sort the list by lowest distance
                <span class="cov0" title="0">vl.list = iSort(vl.list, &amp;target)
                nodesToCheck--

                // If there is a new closest node to the target we need to check the alpha closest nodes
                if closest.ID.String() != vl.list[0].ID.String() </span><span class="cov0" title="0">{
                        closest = vl.list[0]
                        for i, node := range vl.list </span><span class="cov0" title="0">{
                                if i &gt;= alpha </span><span class="cov0" title="0">{
                                        break</span>
                                }

                                <span class="cov0" title="0">if !vl.visited[node] </span><span class="cov0" title="0">{
                                        kademlia.network.SendFindValuePacket(&amp;node, hash, &amp;resultContacts, &amp;resultHash)
                                        vl.visited[node] = true
                                        nodesToCheck++
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">fmt.Println("[LookupValue] Checking if every node has been visited:")
        for _, node := range vl.list </span><span class="cov0" title="0">{
                fmt.Printf("\t%s = %t\n", node.ID.String(), vl.visited[node])
        }</span>

        <span class="cov8" title="1">if len(vl.list) &gt; bucketSize </span><span class="cov0" title="0">{
                *contacts = vl.list[:bucketSize]
        }</span> else<span class="cov8" title="1"> {
                *contacts = vl.list
        }</span>
}

func (kademlia *Kademlia) Store(data []byte) <span class="cov8" title="1">{
        kademlia.hash[kademlia.network.me.ID.String()] = data // This should be an argument
        contacts := make([]Contact, 0)
        kademlia.LookupContact(*kademlia.network.me, &amp;contacts)
        for _, node := range contacts </span><span class="cov0" title="0">{
                kademlia.network.SendStorePacket(&amp;node, data)
        }</span>
}

// inspired by golangprograms.com insertion sort
func iSort(items []Contact, target *Contact) []Contact <span class="cov8" title="1">{
        var n = len(items)

        for i := 1; i &lt; n; i++ </span><span class="cov8" title="1">{
                j := i
                for j &gt; 0 </span><span class="cov8" title="1">{
                        distL := items[j-1].ID.CalcDistance(target.ID)
                        distR := items[j].ID.CalcDistance(target.ID)

                        if distL.Less(distR) </span><span class="cov8" title="1">{
                                items[j-1], items[j] = items[j], items[j-1]
                        }</span>
                        <span class="cov8" title="1">j = j - 1</span>
                }
        }
        <span class="cov8" title="1">return items</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package d7024e

import (
        "encoding/hex"
        "math/rand"
)

// the static number of bytes in a KademliaID
const IDLength = 20

// type definition of a KademliaID
type KademliaID [IDLength]byte

// NewKademliaID returns a new instance of a KademliaID based on the string input
func NewKademliaID(data string) *KademliaID <span class="cov8" title="1">{
        decoded, _ := hex.DecodeString(data)

        newKademliaID := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                newKademliaID[i] = decoded[i]
        }</span>

        <span class="cov8" title="1">return &amp;newKademliaID</span>
}

// NewRandomKademliaID returns a new instance of a random KademliaID,
// change this to a better version if you like
func NewRandomKademliaID() *KademliaID <span class="cov8" title="1">{
        newKademliaID := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                newKademliaID[i] = uint8(rand.Intn(256))
        }</span>
        <span class="cov8" title="1">return &amp;newKademliaID</span>
}

// Less returns true if kademliaID &lt; otherKademliaID (bitwise)
func (kademliaID KademliaID) Less(otherKademliaID *KademliaID) bool <span class="cov8" title="1">{
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                if kademliaID[i] != otherKademliaID[i] </span><span class="cov8" title="1">{
                        return kademliaID[i] &lt; otherKademliaID[i]
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Equals returns true if kademliaID == otherKademliaID (bitwise)
func (kademliaID KademliaID) Equals(otherKademliaID *KademliaID) bool <span class="cov8" title="1">{
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                if kademliaID[i] != otherKademliaID[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// CalcDistance returns a new instance of a KademliaID that is built
// through a bitwise XOR operation betweeen kademliaID and target
func (kademliaID KademliaID) CalcDistance(target *KademliaID) *KademliaID <span class="cov8" title="1">{
        result := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                result[i] = kademliaID[i] ^ target[i]
        }</span>
        <span class="cov8" title="1">return &amp;result</span>
}

// String returns a simple string representation of a KademliaID
func (kademliaID *KademliaID) String() string <span class="cov8" title="1">{
        return hex.EncodeToString(kademliaID[0:IDLength])
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package d7024e

import (
        "encoding/json"
        "fmt"
        "log"
        "net"
        "time"
)

type Network struct {
        me       *Contact
        kademlia *Kademlia
}

/* RPC                         = Command
 * SourceID                = Id of source node
 * SourceIP         = Adress of source
 * TargetID                = Adress/file to find/store
 * Contacts         = List of contacts used by findnode/findvalue
 * Value                = Resulting value of a call in []byte's
 */

type packet struct {
        RPC      string    `json:",omitempty"` // ping, find_value
        SourceID string    `json:",omitempty"` // NODE_123, NODE_2342
        SourceIP string    `json:",omitempty"` // 192.168.1.1, 127.0.0.1
        TargetID string    `json:",omitempty"` // NODE_235235, NODE_76457
        Contacts []Contact `json:",omitempty"` // []Contacts of closest
        Value    []byte    `json:",omitempty"` // 123, 4323452, from hashmap
}

func Init(ip string, port int) *Network <span class="cov8" title="1">{
        me := NewContact(NewRandomKademliaID(), fmt.Sprintf("%s:%d", ip, port))
        newNetwork := &amp;Network{
                me:       &amp;me,
                kademlia: InitKademlia(me),
        }
        fmt.Println("Kademlia ID: ", me.ID.String())
        newNetwork.kademlia.setNetwork(newNetwork)
        return newNetwork
}</span>

func (network *Network) JoinNetwork(ip string) <span class="cov0" title="0">{
        networkContact := NewContact(nil, ip)
        _, err := network.SendPingPacket(&amp;networkContact)
        log.Println(err)
        // Use FindAllNodes and iterate through the results and populate your bucket??
}</span>

func (network *Network) FindAllNodes(target *Contact) []Contact <span class="cov8" title="1">{
        contacts := make([]Contact, 0)
        network.kademlia.LookupContact(*target, &amp;contacts)
        return contacts
}</span>

func (network *Network) GetKademlia() *Kademlia <span class="cov8" title="1">{
        return network.kademlia
}</span>

func (network *Network) Listen() <span class="cov8" title="1">{
        pc, err1 := net.ResolveUDPAddr("udp", network.me.Address)
        fmt.Println("Kademlia started on adress: " + network.me.Address)
        connection, err2 := net.ListenUDP("udp", pc)
        if (err1 != nil) || (err2 != nil) </span><span class="cov0" title="0">{
                fmt.Println("Error :'(")
        }</span>
        <span class="cov8" title="1">defer connection.Close()
        packet := packet{}
        for </span><span class="cov8" title="1">{
                buffer := make([]byte, 1024)
                n, addr, err := connection.ReadFromUDP(buffer)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">json.Unmarshal(buffer[:n], &amp;packet)
                packet.SourceIP = connection.RemoteAddr().String()
                go network.HandleRPC(packet, connection, addr)</span>
        }
}

// Checking which rpc recieved
func (network *Network) HandleRPC(packet packet, connection *net.UDPConn, addr *net.UDPAddr) <span class="cov8" title="1">{
        switch packet.RPC </span>{
        case "ping":<span class="cov8" title="1">
                //do ping stuff
                network.HandlePingPacket(packet)</span>
        case "ping_reply":<span class="cov0" title="0">
                //do ping stuff
                network.HandlePingPacket(packet)</span>
        case "store":<span class="cov0" title="0">
                //do store stuff
                network.HandleStorePacket(packet)</span>
        case "find_node":<span class="cov0" title="0">
                //do find_node stuff
                network.HandleFindNodePacket(packet)</span>
        case "find_node_reply":<span class="cov0" title="0"></span>
                //do find_node stuff
                //network.HandleFindNodeReplyPacket(packet)
        case "find_value":<span class="cov0" title="0">
                //do find_value stuff
                network.HandleFindValuePacket(packet)</span>
        case "find_value_reply":<span class="cov0" title="0"></span>
                //do find_value stuff
                //network.HandleFindValueReplyPacket(packet)
        default:<span class="cov8" title="1">
                //if all else fails, then something is wrong
                fmt.Println("'" + packet.RPC + "' is not an valid RPC!")</span>
        }
}

func (network *Network) HandlePingPacket(packet packet) <span class="cov8" title="1">{
        newNode := NewContact(NewKademliaID(packet.SourceID), packet.SourceIP)
        network.kademlia.routingtab.AddContact(newNode)

        if packet.RPC == "ping" </span><span class="cov8" title="1">{
                network.SendPingReplyPacket(&amp;newNode)
        }</span>
}

func (network *Network) HandleStorePacket(packet packet) <span class="cov0" title="0">{
        _, ok := network.kademlia.hash[packet.TargetID]

        if !ok </span><span class="cov0" title="0">{
                network.kademlia.hash[packet.TargetID] = packet.Value

                createdPacket := network.CreatePacket("", packet.SourceID, "", nil, []byte("SUCCESS"))
                _, err := network.SendPacket(createdPacket, packet.SourceIP)
                log.Println(err)
        }</span> else<span class="cov0" title="0"> {
                createdPacket := network.CreatePacket("", packet.SourceID, "", nil, []byte("FAIL"))
                _, err := network.SendPacket(createdPacket, packet.SourceIP)
                log.Println(err)
        }</span>
}

func (network *Network) HandleFindNodePacket(packet packet) <span class="cov0" title="0">{
        closeContacts := network.kademlia.routingtab.FindClosestContacts(NewKademliaID(packet.TargetID), bucketSize)

        createdPacket := network.CreatePacket("", packet.SourceID, "", closeContacts, nil)
        _, err := network.SendPacket(createdPacket, packet.SourceIP)
        log.Println(err)
}</span>

func (network *Network) HandleFindValuePacket(packet packet) {
        value, ok := network.kademlia.hash[packet.TargetID]

        if !ok {
                closeContacts := network.kademlia.routingtab.FindClosestContacts(NewKademliaID(packet.TargetID), bucketSize)
                createdPacket := network.CreatePacket("find_value_reply", packet.SourceID, "", closeContacts, nil)
        </span>        _, err := network.SendPacket(createdPacket, packet.SourceIP)
                log.Println(err)
        } else {
                createdPacket := network.CreatePacket("find_value_reply", packet.SourceID, "", nil, value)
                _, err := network.SendPacket(createdPacket, packet.SourceIP)
                log.Pr</span><span class="cov0" title="0">intln(err)
        }
}

// Creates an RPC packet containing sender data and possibility for contact array
fu</span>nc (n<span class="cov0" title="0">etwork *Network) CreatePacket(rpc string, sourceid string, targetid string, contacts []Contact, value []byte) *packet {
        createdPacket := &amp;packet{
                RPC:      rpc,
                SourceID: sourceid,
                </span>TargetID: targetid,
                Contacts: contacts,
                Value:    value,
        }
        return createdPacket
}

func (network *Network) SendPacket(packet *packet, addr string) (*net.UDPConn, error) {
        remoteAddress, err := net.ResolveUDPAddr("udp", addr)
        connection, err := net.DialUDP("udp", nil, remoteAddress)
        log.Println(err)
        defer connection.Close()
        marshalledPacket, err := json.Marshal(packet)
        </span>_, err = connection.Write(marshalledPacket)
        log.Println(err)
        fmt.Println("SENT: " + string(marshalledPacket))
        return connection, err
}

func (network *Network) SendPingReplyPacket(contact *Contact) {
        createdPacket := network.CreatePacket("ping_reply", network.me.ID.String(), "", nil, nil)
        _, err := network.SendPacket(createdPacket, contact.Address)
        log.Println(err)
}

f</span>unc (network *Network) SendPingPacket(contact *Contact) (packet, error) {
        createdPacket := network.CreatePacket("ping", network.me.ID.String(), "", nil, nil)
        connection, err := network.SendPacket(createdPacket, contact.<span class="cov8" title="1">Address)
}

func (network *Network) SendFindNodePacket(contact *Contact, target *Contact, results *[]Contact) {
        </span>createdPacket := network.CreatePacket("find_node", network.me.ID.String(), contact.ID.String(), nil, nil)
        connection, err := network.SendPacket(createdPacket, contact.Address)
        log.Println(err)
        newPacket := packet{}
        responsePacket := make([]byte, 1024)
        connection.SetReadDeadline(time.Now().Add(300 * time.Millisecond))

        length, err := connection.Read(responsePacket)
        log.</span><span class="cov0" title="0">Println(err)
        err = json.Unmarshal(responsePacket[:length], &amp;newPacket)

        res := append(*</span><span class="cov0" title="0">results, newPacket.Contacts...)
        *results = res
}
</span>
fu<span class="cov0" title="0">nc (network *Network) SendFindValuePacket(contact *Contact, hash string, resultContacts *[]Contact, resultHash *string) {
        createdPacket := network.CreatePacket("find_value", network.me.ID.String(), "", nil, []byte(hash))
        connection, err := network.SendPacket(createdPacket, contact.Address)
        log.Println(err)
        newPacket := packet{}
        responsePacket := make</span>([]byte, 1024)
        connection.SetReadDeadline(time.Now().Add(300 * time.Millisecond))
        <span class="cov0" title="0">length, err := connec</span>tion.Read(responsePacket)
        err = json.Unmarshal(responsePacket[:length], &amp;newPacket)

        resContacts := append(*resultContacts, newPacket.Contacts...)
        *resultContacts = resContacts

        *resultHash = string(newPacket.Value)

        // We need to decide what to do after recieving the answer???

        // PROBABLY NEED SOME CHANNELS FOR THIS SO WILL PROBABLY NEED TO DO
        // KADEMLIA.GO PROGRAMMING BEFORE WE START THIS MESS
}

func (network *Network) SendStorePacket(contact *Contact, data []byte) {
        createdPacket := network.CreatePacket("store", network.me.ID.String(), "", nil, data)
        connection, err := network.SendPacket(createdPacket, contact.Address)
        </span>log.Println(err)
        newPacket := packet{}
        responsePacket := make([]byte, 1024)
        connection.SetReadDeadline(time.Now().Add(300 * time.Millisecond))
        length, err := connection.Read(responsePacket)
        err = json.Unmarshal(responsePacket[:length], &amp;newPacket)
        fmt.Println(string(newPacket.Value))
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package d7024e

const bucketSize = 20

// RoutingTable definition
// keeps a refrence contact of me and an array of buckets
type RoutingTable struct {
        me      Contact
        buckets [IDLength * 8]*bucket
}

// NewRoutingTable returns a new instance of a RoutingTable
func NewRoutingTable(me Contact) *RoutingTable <span class="cov8" title="1">{
        routingTable := &amp;RoutingTable{}
        for i := 0; i &lt; IDLength*8; i++ </span><span class="cov8" title="1">{
                routingTable.buckets[i] = newBucket()
        }</span>
        <span class="cov8" title="1">routingTable.me = me
        return routingTable</span>
}

// AddContact add a new contact to the correct Bucket
func (routingTable *RoutingTable) AddContact(contact Contact) <span class="cov8" title="1">{
        bucketIndex := routingTable.getBucketIndex(contact.ID)
        bucket := routingTable.buckets[bucketIndex]
        bucket.AddContact(contact)
}</span>

// FindClosestContacts finds the count closest Contacts to the target in the RoutingTable
func (routingTable *RoutingTable) FindClosestContacts(target *KademliaID, count int) []Contact <span class="cov8" title="1">{
        var candidates ContactCandidates
        bucketIndex := routingTable.getBucketIndex(target)
        bucket := routingTable.buckets[bucketIndex]

        candidates.Append(bucket.GetContactAndCalcDistance(target))

        for i := 1; (bucketIndex-i &gt;= 0 || bucketIndex+i &lt; IDLength*8) &amp;&amp; candidates.Len() &lt; count; i++ </span><span class="cov8" title="1">{
                if bucketIndex-i &gt;= 0 </span><span class="cov8" title="1">{
                        bucket = routingTable.buckets[bucketIndex-i]
                        candidates.Append(bucket.GetContactAndCalcDistance(target))
                }</span>
                <span class="cov8" title="1">if bucketIndex+i &lt; IDLength*8 </span><span class="cov8" title="1">{
                        bucket = routingTable.buckets[bucketIndex+i]
                        candidates.Append(bucket.GetContactAndCalcDistance(target))
                }</span>
        }

        <span class="cov8" title="1">candidates.Sort()

        if count &gt; candidates.Len() </span><span class="cov8" title="1">{
                count = candidates.Len()
        }</span>

        <span class="cov8" title="1">return candidates.GetContacts(count)</span>
}

// getBucketIndex get the correct Bucket index for the KademliaID
func (routingTable *RoutingTable) getBucketIndex(id *KademliaID) int <span class="cov8" title="1">{
        distance := id.CalcDistance(routingTable.me.ID)
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt; 8; j++ </span><span class="cov8" title="1">{
                        if (distance[i]&gt;&gt;uint8(7-j))&amp;0x1 != 0 </span><span class="cov8" title="1">{
                                return i*8 + j
                        }</span>
                }
        }

        <span class="cov8" title="1">return IDLength*8 - 1</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
