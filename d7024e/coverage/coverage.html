
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>d7024e: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">kademlia/d7024e/bucket.go (100.0%)</option>
				
				<option value="file1">kademlia/d7024e/cli.go (0.0%)</option>
				
				<option value="file2">kademlia/d7024e/contact.go (100.0%)</option>
				
				<option value="file3">kademlia/d7024e/kademlia.go (3.2%)</option>
				
				<option value="file4">kademlia/d7024e/kademliaid.go (100.0%)</option>
				
				<option value="file5">kademlia/d7024e/network.go (36.1%)</option>
				
				<option value="file6">kademlia/d7024e/routingtable.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package d7024e

import (
        "container/list"
)

// bucket definition
// contains a List
type bucket struct {
        list *list.List
}

// newBucket returns a new instance of a bucket
func newBucket() *bucket <span class="cov8" title="1">{
        bucket := &amp;bucket{}
        bucket.list = list.New()
        return bucket
}</span>

// AddContact adds the Contact to the front of the bucket
// or moves it to the front of the bucket if it already existed
func (bucket *bucket) AddContact(contact Contact) <span class="cov8" title="1">{
        var element *list.Element
        for e := bucket.list.Front(); e != nil; e = e.Next() </span><span class="cov8" title="1">{
                nodeID := e.Value.(Contact).ID

                if (contact).ID.Equals(nodeID) </span><span class="cov8" title="1">{
                        element = e
                }</span>
        }

        <span class="cov8" title="1">if element == nil </span><span class="cov8" title="1">{
                if bucket.list.Len() &lt; bucketSize </span><span class="cov8" title="1">{
                        bucket.list.PushFront(contact)
                }</span>
        } else<span class="cov8" title="1"> {
                bucket.list.MoveToFront(element)
        }</span>
}

// GetContactAndCalcDistance returns an array of Contacts where
// the distance has already been calculated
func (bucket *bucket) GetContactAndCalcDistance(target *KademliaID) []Contact <span class="cov8" title="1">{
        var contacts []Contact

        for elt := bucket.list.Front(); elt != nil; elt = elt.Next() </span><span class="cov8" title="1">{
                contact := elt.Value.(Contact)
                contact.CalcDistance(target)
                contacts = append(contacts, contact)
        }</span>

        <span class="cov8" title="1">return contacts</span>
}

// Len return the size of the bucket
func (bucket *bucket) Len() int <span class="cov8" title="1">{
        return bucket.list.Len()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package d7024e

import (
        "bufio"
        "fmt"
        "os"
        "strings"
)

func (kad *Kademlia) CLI(test bool, scanner *bufio.Scanner) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if test </span><span class="cov0" title="0">{
                        fmt.Print("[ROOT] Enter a command: ")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Print("Enter a command: ")
                }</span>

                <span class="cov0" title="0">scanner.Scan()
                cmd := scanner.Text()
                fmt.Println("Running command:", cmd)

                switch </span>{
                case strings.Contains(cmd, "put "):<span class="cov0" title="0">
                        hash := cmd[4:]
                        kad.Store([]byte(hash))</span>
                case strings.Contains(cmd, "get "):<span class="cov0" title="0">
                        hash := cmd[4:]
                        if len(hash) != IDLength*2 </span><span class="cov0" title="0">{
                                fmt.Println("Wrong input")
                                break</span>
                        }
                        <span class="cov0" title="0">value, contacts := kad.LookupData(hash)
                        fmt.Println("[CLI] Value:", value)
                        fmt.Println("[CLI] Contacts:", contacts)</span>
                case strings.Contains(cmd, "exit"):<span class="cov0" title="0">
                        os.Exit(0)</span>
                case strings.Contains(cmd, "list"):<span class="cov0" title="0">
                        fmt.Println("Values stored: ")
                        for key, element := range kad.hash </span><span class="cov0" title="0">{
                                fmt.Println("\tKey:", key, "=&gt;", "Element:", string(element))
                        }</span>
                case strings.Contains(cmd, "me"):<span class="cov0" title="0">
                        fmt.Println("ID: ", kad.network.me.ID.String(), " IP: ", kad.network.me.Address)</span>
                case strings.Contains(cmd, "contacts"):<span class="cov0" title="0">
                        fmt.Println("Saved contacts: ")
                        for _, bucket := range kad.routingtab.buckets </span><span class="cov0" title="0">{
                                for _, cont := range bucket.GetContactAndCalcDistance(NewKademliaID("0000000000000000000000000000000000000000")) </span><span class="cov0" title="0">{
                                        fmt.Println("\tID: ", cont.ID.String(), " IP: ", cont.Address)
                                }</span>
                        }
                default:<span class="cov0" title="0">
                        fmt.Println("Error: Wrong command.")</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package d7024e

import (
        "fmt"
        "sort"
)

// Contact definition
// stores the KademliaID, the ip address and the distance
type Contact struct {
        ID       *KademliaID
        Address  string
        distance *KademliaID
}

// NewContact returns a new instance of a Contact
func NewContact(id *KademliaID, address string) Contact <span class="cov8" title="1">{
        return Contact{id, address, nil}
}</span>

// CalcDistance calculates the distance to the target and
// fills the contacts distance field
func (contact *Contact) CalcDistance(target *KademliaID) <span class="cov8" title="1">{
        contact.distance = contact.ID.CalcDistance(target)
}</span>

// Less returns true if contact.distance &lt; otherContact.distance
func (contact *Contact) Less(otherContact *Contact) bool <span class="cov8" title="1">{
        return contact.distance.Less(otherContact.distance)
}</span>

// String returns a simple string representation of a Contact
func (contact *Contact) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(`contact("%s", "%s")`, contact.ID, contact.Address)
}</span>

// ContactCandidates definition
// stores an array of Contacts
type ContactCandidates struct {
        contacts []Contact
}

// Append an array of Contacts to the ContactCandidates
func (candidates *ContactCandidates) Append(contacts []Contact) <span class="cov8" title="1">{
        candidates.contacts = append(candidates.contacts, contacts...)
}</span>

// GetContacts returns the first count number of Contacts
func (candidates *ContactCandidates) GetContacts(count int) []Contact <span class="cov8" title="1">{
        return candidates.contacts[:count]
}</span>

// Sort the Contacts in ContactCandidates
func (candidates *ContactCandidates) Sort() <span class="cov8" title="1">{
        sort.Sort(candidates)
}</span>

// Len returns the length of the ContactCandidates
func (candidates *ContactCandidates) Len() int <span class="cov8" title="1">{
        return len(candidates.contacts)
}</span>

// Swap the position of the Contacts at i and j
// WARNING does not check if either i or j is within range
func (candidates *ContactCandidates) Swap(i, j int) <span class="cov8" title="1">{
        candidates.contacts[i], candidates.contacts[j] = candidates.contacts[j], candidates.contacts[i]
}</span>

// Less returns true if the Contact at index i is smaller than
// the Contact at index j
func (candidates *ContactCandidates) Less(i, j int) bool <span class="cov8" title="1">{
        return candidates.contacts[i].Less(&amp;candidates.contacts[j])
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package d7024e

import "fmt"

type Kademlia struct {
        network    *Network
        routingtab *RoutingTable
        hash       map[string][]byte
}

func InitKademlia(me Contact) *Kademlia <span class="cov8" title="1">{
        newKademlia := &amp;Kademlia{
                routingtab: NewRoutingTable(me),
                hash:       make(map[string][]byte),
        }
        return newKademlia
}</span>

var alpha int = 3

func (kademlia *Kademlia) setNetwork(network *Network) <span class="cov8" title="1">{
        kademlia.network = network
}</span>

func (kademlia *Kademlia) LookupContact(target *Contact) []Contact <span class="cov0" title="0">{
        var shortlist ContactCandidates
        shortlist.contacts = kademlia.routingtab.FindClosestContacts(target.ID, alpha)
        closestNode := shortlist.contacts[0]
        var visitedNodes []Contact
        for _, contact := range shortlist.contacts </span><span class="cov0" title="0">{
                if !Contains(visitedNodes, contact) &amp;&amp; (contact.Address != kademlia.network.me.Address) </span><span class="cov0" title="0">{
                        kademlia.network.SendPingPacket(contact)
                        pong := string(&lt;-kademlia.network.findVal)
                        if pong == "pong" </span><span class="cov0" title="0">{
                                kademlia.network.SendFindNodePacket(contact, target)
                                visitedNodes = append(visitedNodes, contact)
                                k_triples := &lt;-kademlia.network.findCont
                                for _, cont := range k_triples </span><span class="cov0" title="0">{
                                        cont.CalcDistance(target.ID)
                                        if !Contains(shortlist.contacts, cont) </span><span class="cov0" title="0">{
                                                shortlist.contacts = append(shortlist.contacts, cont)
                                        }</span>
                                        <span class="cov0" title="0">if cont.Less(&amp;closestNode) </span><span class="cov0" title="0">{
                                                closestNode = cont
                                        }</span>
                                }
                        }
                }
        }

        /*fmt.Println("[LookupContact] Contacts before loop: ")
        for _, n := range shortlist.contacts {
                fmt.Println(n.String())
        }
        */

        <span class="cov0" title="0">shortlist.Sort()
        for len(visitedNodes) &lt; bucketSize &amp;&amp; !Contains(visitedNodes, closestNode) </span><span class="cov0" title="0">{
                // for NODES VISITED &lt; 20 AND CLOSESTNODE IS A NEW NODE
                // find 3 closest UNVISITED NODES and do it all over
                i := 0
                for _, contact := range shortlist.contacts </span><span class="cov0" title="0">{
                        if !Contains(visitedNodes, contact) </span><span class="cov0" title="0">{
                                i++
                                kademlia.network.SendPingPacket(contact)
                                pong := string(&lt;-kademlia.network.findVal)
                                if pong == "pong" </span><span class="cov0" title="0">{
                                        kademlia.network.SendFindNodePacket(contact, target)
                                        visitedNodes = append(visitedNodes, contact)
                                        k_triples := &lt;-kademlia.network.findCont
                                        for _, cont := range k_triples </span><span class="cov0" title="0">{
                                                cont.CalcDistance(target.ID)
                                                if !Contains(shortlist.contacts, cont) </span><span class="cov0" title="0">{
                                                        shortlist.contacts = append(shortlist.contacts, cont)
                                                }</span>
                                                <span class="cov0" title="0">if cont.Less(&amp;closestNode) </span><span class="cov0" title="0">{
                                                        closestNode = cont
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if i == 3 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">shortlist.Sort()</span>
        }

        <span class="cov0" title="0">if shortlist.Len() &lt; bucketSize </span><span class="cov0" title="0">{
                return shortlist.contacts
        }</span> else<span class="cov0" title="0"> {
                return shortlist.contacts[:bucketSize]
        }</span>
}

func (kademlia *Kademlia) LookupData(hash string) (string, []Contact) <span class="cov0" title="0">{
        var shortlist ContactCandidates
        target := NewContact(NewKademliaID(hash), "")
        shortlist.contacts = kademlia.routingtab.FindClosestContacts(target.ID, alpha)
        var value string
        var k_triples []Contact
        var visitedNodes ContactCandidates
        counter := 0
        for len(shortlist.contacts) &gt; 0 </span><span class="cov0" title="0">{
                kademlia.network.SendFindValuePacket(shortlist.contacts[0], hash)
                value = string(&lt;-kademlia.network.findVal)
                k_triples = &lt;-kademlia.network.findCont
                if value != "" </span><span class="cov0" title="0">{
                        return value, make([]Contact, 0)
                }</span>
                <span class="cov0" title="0">UpdateShortlist(k_triples, &amp;shortlist, &amp;visitedNodes, &amp;target)
                counter += 1</span>
        }
        <span class="cov0" title="0">visitedNodes.Sort()
        var result []Contact
        for i, contact := range visitedNodes.contacts </span><span class="cov0" title="0">{
                if i &lt; 3 </span><span class="cov0" title="0">{
                        result = append(result, contact)
                }</span>
        }
        <span class="cov0" title="0">return "", result</span>
}

func UpdateShortlist(k_triples []Contact, shortlist *ContactCandidates, visited *ContactCandidates, target *Contact) <span class="cov0" title="0">{
        visited.contacts = append(visited.contacts, shortlist.contacts[0])
        for _, s := range k_triples </span><span class="cov0" title="0">{
                if !Contains(visited.contacts, s) &amp;&amp; !Contains(shortlist.contacts, s) </span><span class="cov0" title="0">{
                        s.CalcDistance(target.ID)
                        shortlist.contacts = append(shortlist.contacts, s)
                }</span>
        }
        <span class="cov0" title="0">if len(shortlist.contacts) == 1 </span><span class="cov0" title="0">{
                shortlist.contacts = []Contact{}
        }</span> else<span class="cov0" title="0"> {
                shortlist.contacts = shortlist.contacts[1:]
        }</span>
}

func Contains(visited []Contact, contact Contact) bool <span class="cov0" title="0">{
        for _, a := range visited </span><span class="cov0" title="0">{
                if a.ID.Equals(contact.ID) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (kademlia *Kademlia) Store(data []byte) <span class="cov0" title="0">{
        value, ok := kademlia.hash[kademlia.network.me.ID.String()]
        if !ok </span><span class="cov0" title="0">{
                kademlia.hash[kademlia.network.me.ID.String()] = data
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Immutable data: Already stored:", string(value))
                fmt.Println("Reference to Delimitations #1:")
                return
        }</span>

        <span class="cov0" title="0">contacts := kademlia.LookupContact(kademlia.network.me)
        //fmt.Println("[Store] contacts: ")
        for _, contact := range contacts </span><span class="cov0" title="0">{
                fmt.Println(contact.String())
        }</span>
        <span class="cov0" title="0">var res string
        for _, node := range contacts </span><span class="cov0" title="0">{
                if !node.ID.Equals(kademlia.network.me.ID) </span><span class="cov0" title="0">{
                        kademlia.network.SendStorePacket(node, data)
                        res = string(&lt;-kademlia.network.findVal)
                        if res == "SUCCESS" </span><span class="cov0" title="0">{
                                fmt.Println("Saved at: ", node.ID.String())
                                //kademlia.hash[kademlia.network.me.ID.String()] = data
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("Could not store data at: ", node.ID.String())
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package d7024e

import (
        "encoding/hex"
        "math/rand"
)

// the static number of bytes in a KademliaID
const IDLength = 20

// type definition of a KademliaID
type KademliaID [IDLength]byte

// NewKademliaID returns a new instance of a KademliaID based on the string input
func NewKademliaID(data string) *KademliaID <span class="cov8" title="1">{
        decoded, _ := hex.DecodeString(data)

        newKademliaID := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                newKademliaID[i] = decoded[i]
        }</span>

        <span class="cov8" title="1">return &amp;newKademliaID</span>
}

// NewRandomKademliaID returns a new instance of a random KademliaID,
// change this to a better version if you like
func NewRandomKademliaID() *KademliaID <span class="cov8" title="1">{
        newKademliaID := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                newKademliaID[i] = uint8(rand.Intn(256))
        }</span>
        <span class="cov8" title="1">return &amp;newKademliaID</span>
}

// Less returns true if kademliaID &lt; otherKademliaID (bitwise)
func (kademliaID KademliaID) Less(otherKademliaID *KademliaID) bool <span class="cov8" title="1">{
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                if kademliaID[i] != otherKademliaID[i] </span><span class="cov8" title="1">{
                        return kademliaID[i] &lt; otherKademliaID[i]
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Equals returns true if kademliaID == otherKademliaID (bitwise)
func (kademliaID KademliaID) Equals(otherKademliaID *KademliaID) bool <span class="cov8" title="1">{
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                if kademliaID[i] != otherKademliaID[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// CalcDistance returns a new instance of a KademliaID that is built
// through a bitwise XOR operation betweeen kademliaID and target
func (kademliaID KademliaID) CalcDistance(target *KademliaID) *KademliaID <span class="cov8" title="1">{
        result := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                result[i] = kademliaID[i] ^ target[i]
        }</span>
        <span class="cov8" title="1">return &amp;result</span>
}

// String returns a simple string representation of a KademliaID
func (kademliaID *KademliaID) String() string <span class="cov8" title="1">{
        return hex.EncodeToString(kademliaID[0:IDLength])
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package d7024e

import (
        "encoding/json"
        "fmt"
        "log"
        "net"
        "time"
)

type Network struct {
        me       *Contact
        kademlia *Kademlia
        findCont chan []Contact
        findVal  chan []byte
}

/* RPC                         = Command
 * SourceID                = Id of source node
 * SourceIP         = Adress of source
 * TargetID                = Adress/file to find/store
 * Contacts         = List of contacts used by findnode/findvalue
 * Value                = Resulting value of a call in []byte's
 */

type packet struct {
        RPC      string    `json:",omitempty"` // ping, find_value
        SourceID string    `json:",omitempty"` // NODE_123, NODE_2342
        SourceIP string    `json:",omitempty"` // 192.168.1.1, 127.0.0.1
        TargetID string    `json:",omitempty"` // NODE_235235, NODE_76457
        Contacts []Contact `json:",omitempty"` // []Contacts of closest
        Value    []byte    `json:",omitempty"` // 123, 4323452, from hashmap
}

func Init(ip string, port int) *Network <span class="cov8" title="1">{
        me := NewContact(NewRandomKademliaID(), fmt.Sprintf("%s:%d", ip, port))
        newNetwork := &amp;Network{
                me:       &amp;me,
                kademlia: InitKademlia(me),
                findCont: make(chan []Contact),
                findVal:  make(chan []byte),
        }

        fmt.Println("Kademlia ID: ", me.ID.String())
        newNetwork.kademlia.setNetwork(newNetwork)
        return newNetwork
}</span>

func InitRoot(id string, ip string, port int) *Network <span class="cov0" title="0">{
        me := NewContact(NewKademliaID(id), fmt.Sprintf("%s:%d", ip, port))
        newNetwork := &amp;Network{
                me:       &amp;me,
                kademlia: InitKademlia(me),
                findCont: make(chan []Contact),
                findVal:  make(chan []byte),
        }

        fmt.Println("Kademlia ID: ", me.ID.String())
        newNetwork.kademlia.setNetwork(newNetwork)
        return newNetwork
}</span>

func (network *Network) JoinNetwork(id string, ip string) <span class="cov0" title="0">{
        fmt.Println("[JoinNetwork]")
        time.Sleep(time.Second * 1)
        networkContact := NewContact(NewKademliaID(id), ip)
        network.SendPingPacket(networkContact)
        if string(&lt;-network.findVal) == "pong" </span><span class="cov0" title="0">{
                fmt.Println("[JoinNetwork PONG] Adding contact: ", networkContact.ID)
                network.kademlia.routingtab.AddContact(networkContact)
        }</span>

        <span class="cov0" title="0">contacts := network.kademlia.LookupContact(network.me)
        fmt.Println("[JoinNetwork Between] My contact info: ", network.me)

        for _, cont := range contacts </span><span class="cov0" title="0">{
                if !cont.ID.Equals(network.me.ID) </span><span class="cov0" title="0">{
                        fmt.Println("[JoinNetwork LC] Adding contact: ", cont.ID)
                        network.kademlia.routingtab.AddContact(cont)
                }</span>
        }
}

func ErrorLogger(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}

func (network *Network) FindAllNodes(target *Contact) []Contact <span class="cov0" title="0">{
        return network.kademlia.LookupContact(target)
}</span>

func (network *Network) GetKademlia() *Kademlia <span class="cov8" title="1">{
        return network.kademlia
}</span>

func (packet *packet) String() string <span class="cov8" title="1">{
        printString := string("\n\tRPC: " + packet.RPC +
                "\n\tSourceID: " + packet.SourceID +
                "\n\tSourceIP: " + packet.SourceIP +
                "\n\tTargetID: " + packet.TargetID)
        contactsString := "\n\tContacts: \n"
        for _, contact := range packet.Contacts </span><span class="cov0" title="0">{
                contactsString = contactsString + "\t\t" + contact.String() + "\n"
        }</span>
        <span class="cov8" title="1">printString = printString + contactsString + "\tValue: " + string(packet.Value)

        return printString</span>
}

func (network *Network) Listen() <span class="cov8" title="1">{
        pc, err1 := net.ResolveUDPAddr("udp", network.me.Address)
        fmt.Println("Kademlia is listening on address: "+network.me.Address, network.me.ID.String())
        connection, err2 := net.ListenUDP("udp", pc)
        if (err1 != nil) || (err2 != nil) </span><span class="cov0" title="0">{
                fmt.Println("Error :'(")
        }</span>
        <span class="cov8" title="1">defer connection.Close()
        for </span><span class="cov8" title="1">{
                packet := packet{}
                buffer := make([]byte, 65536)
                fmt.Println("Listening")
                n, addr, err := connection.ReadFromUDP(buffer)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">json.Unmarshal(buffer[:n], &amp;packet)
                fmt.Println("\033[32m", "RECIEVED &lt;", addr, "&gt;: ", packet.String(), "\033[0m")
                newContact := NewContact(NewKademliaID(packet.SourceID), packet.SourceIP)
                if !newContact.ID.Equals(network.me.ID) </span><span class="cov0" title="0">{
                        network.kademlia.routingtab.AddContact(newContact)
                }</span>
                <span class="cov0" title="0">network.HandleRPC(packet, connection, addr)</span>
        }
}

// Checking which rpc recieved
func (network *Network) HandleRPC(packet packet, connection *net.UDPConn, addr *net.UDPAddr) <span class="cov8" title="1">{
        switch packet.RPC </span>{
        case "ping":<span class="cov8" title="1">
                //do ping stuff
                network.HandlePingPongPacket(packet)</span>
        case "pong":<span class="cov0" title="0">
                //do ping stuff
                network.findVal &lt;- []byte("pong")</span>
                //network.HandlePingPongPacket(packet)
        case "store":<span class="cov0" title="0">
                //do store stuff
                network.HandleStorePacket(packet)</span>
        case "store_reply":<span class="cov0" title="0">
                //do store_reply stuff
                network.findVal &lt;- packet.Value</span>
        case "find_node":<span class="cov0" title="0">
                //do find_node stuff
                network.HandleFindNodePacket(packet)</span>
        case "find_node_reply":<span class="cov0" title="0">
                //do find_node_reply stuff
                network.findCont &lt;- packet.Contacts</span>
        case "find_value":<span class="cov0" title="0">
                //do find_value stuff
                network.HandleFindValuePacket(packet)</span>
        case "find_value_reply":<span class="cov0" title="0">
                //do find_value_reply stuff
                network.findVal &lt;- packet.Value
                network.findCont &lt;- packet.Contacts</span>
        default:<span class="cov8" title="1">
                //if all else fails, then something is wrong
                fmt.Println("'" + packet.RPC + "' is not an valid RPC!")</span>
        }
}

func (network *Network) HandlePingPongPacket(packet packet) <span class="cov8" title="1">{ //, connection *net.UDPConn, addr *net.UDPAddr) {
        newNode := NewContact(NewKademliaID(packet.SourceID), packet.SourceIP)
        if !newNode.ID.Equals(network.me.ID) </span><span class="cov0" title="0">{
                network.kademlia.routingtab.AddContact(newNode)
        }</span>

        <span class="cov8" title="1">network.SendPongPacket(newNode)</span>
}

func (network *Network) HandleStorePacket(packet packet) <span class="cov0" title="0">{
        _, ok := network.kademlia.hash[packet.SourceID]
        emptyConts := make([]Contact, 0)

        if !ok </span><span class="cov0" title="0">{
                network.kademlia.hash[packet.SourceID] = packet.Value

                createdPacket := network.CreatePacket("store_reply", network.me.Address, network.me.ID.String(), packet.SourceID, emptyConts, []byte("SUCCESS"))
                network.SendPacket(createdPacket, packet.SourceIP)
        }</span> else<span class="cov0" title="0"> {
                createdPacket := network.CreatePacket("store_reply", network.me.Address, network.me.ID.String(), packet.SourceID, emptyConts, []byte("FAIL"))
                network.SendPacket(createdPacket, packet.SourceIP)
        }</span>
}

func (network *Network) HandleFindNodePacket(packet packet) <span class="cov0" title="0">{
        closeContacts := network.kademlia.routingtab.FindClosestContacts(NewKademliaID(packet.TargetID), bucketSize)

        createdPacket := network.CreatePacket("find_node_reply", network.me.Address, network.me.ID.String(), packet.SourceID, closeContacts, []byte(""))
        network.SendPacket(createdPacket, packet.SourceIP)
}</span>

func (network *Network) HandleFindValuePacket(packet packet) <span class="cov0" title="0">{
        value, ok := network.kademlia.hash[string(packet.Value)]
        fmt.Println("\033[31m", ok)

        if !ok </span><span class="cov0" title="0">{
                closeContacts := network.kademlia.routingtab.FindClosestContacts(NewKademliaID(string(packet.Value)), bucketSize)
                createdPacket := network.CreatePacket("find_value_reply", network.me.Address, network.me.ID.String(), packet.SourceID, closeContacts, []byte(""))
                network.SendPacket(createdPacket, packet.SourceIP)
        }</span> else<span class="cov0" title="0"> {
                emptyConts := make([]Contact, 0)
                createdPacket := network.CreatePacket("find_value_reply", network.me.Address, network.me.ID.String(), packet.SourceID, emptyConts, value) // Av någon anledning så ger den en lista av
                network.SendPacket(createdPacket, packet.SourceIP)
        }</span>
}

// Creates an RPC packet containing sender data and possibility for contact array
func (network *Network) CreatePacket(rpc string, sourceip string, sourceid string, targetid string, contacts []Contact, value []byte) *packet <span class="cov8" title="1">{
        createdPacket := &amp;packet{
                RPC:      rpc,
                SourceID: sourceid,
                SourceIP: sourceip,
                TargetID: targetid,
                Contacts: contacts,
                Value:    value,
        }
        return createdPacket
}</span>

func (network *Network) SendPacket(packet *packet, addr string) <span class="cov8" title="1">{
        // Returns an address of UDP end point
        remoteAddress, err := net.ResolveUDPAddr("udp", addr)
        ErrorLogger(err)

        // Dial the UDP address
        connection, err := net.DialUDP("udp", nil, remoteAddress)
        ErrorLogger(err)
        defer connection.Close()

        marshalledPacket, err := json.Marshal(packet)
        ErrorLogger(err)

        // Write to connection
        _, err = connection.Write(marshalledPacket)
        ErrorLogger(err)
        fmt.Println("\033[33m", "SENT &lt;", addr, "&gt;: ", packet.String(), "\033[0m")
}</span>

func (network *Network) SendPingPacket(contact Contact) <span class="cov0" title="0">{
        createdPacket := network.CreatePacket("ping", network.me.Address, network.me.ID.String(), contact.ID.String(), nil, nil)
        network.SendPacket(createdPacket, contact.Address)
}</span>

func (network *Network) SendPongPacket(contact Contact) <span class="cov8" title="1">{
        createdPacket := network.CreatePacket("pong", network.me.Address, network.me.ID.String(), contact.ID.String(), nil, nil)
        network.SendPacket(createdPacket, contact.Address)
}</span>

func (network *Network) SendFindNodePacket(contact Contact, target *Contact) <span class="cov0" title="0">{
        createdPacket := network.CreatePacket("find_node", network.me.Address, network.me.ID.String(), target.ID.String(), nil, nil)
        network.SendPacket(createdPacket, contact.Address)
}</span>

func (network *Network) SendFindValuePacket(contact Contact, hash string) <span class="cov0" title="0">{
        createdPacket := network.CreatePacket("find_value", network.me.Address, network.me.ID.String(), contact.ID.String(), nil, []byte(hash))
        network.SendPacket(createdPacket, contact.Address)
}</span>

func (network *Network) SendStorePacket(contact Contact, data []byte) <span class="cov0" title="0">{
        createdPacket := network.CreatePacket("store", network.me.Address, network.me.ID.String(), contact.ID.String(), nil, data)
        network.SendPacket(createdPacket, contact.Address)
}</span>

// Gotten from https://github.com/holwech/UDP-module/blob/e03eccee9bfb5585d2c27c7e153fef273285099c/communication.go#L15
func GetLocalIP() string <span class="cov0" title="0">{
        var localIP string
        addr, err := net.InterfaceAddrs()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("GetLocalIP in communication failed")
                return "localhost"
        }</span>
        <span class="cov0" title="0">for _, val := range addr </span><span class="cov0" title="0">{
                if ip, ok := val.(*net.IPNet); ok &amp;&amp; !ip.IP.IsLoopback() </span><span class="cov0" title="0">{
                        if ip.IP.To4() != nil </span><span class="cov0" title="0">{
                                localIP = ip.IP.String()
                        }</span>
                }
        }
        <span class="cov0" title="0">return localIP</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package d7024e

const bucketSize = 20

// RoutingTable definition
// keeps a refrence contact of me and an array of buckets
type RoutingTable struct {
        me      Contact
        buckets [IDLength * 8]*bucket
}

// NewRoutingTable returns a new instance of a RoutingTable
func NewRoutingTable(me Contact) *RoutingTable <span class="cov8" title="1">{
        routingTable := &amp;RoutingTable{}
        for i := 0; i &lt; IDLength*8; i++ </span><span class="cov8" title="1">{
                routingTable.buckets[i] = newBucket()
        }</span>
        <span class="cov8" title="1">routingTable.me = me
        return routingTable</span>
}

// AddContact add a new contact to the correct Bucket
func (routingTable *RoutingTable) AddContact(contact Contact) <span class="cov8" title="1">{
        bucketIndex := routingTable.getBucketIndex(contact.ID)
        bucket := routingTable.buckets[bucketIndex]
        bucket.AddContact(contact)
}</span>

// FindClosestContacts finds the count closest Contacts to the target in the RoutingTable
func (routingTable *RoutingTable) FindClosestContacts(target *KademliaID, count int) []Contact <span class="cov8" title="1">{
        var candidates ContactCandidates
        bucketIndex := routingTable.getBucketIndex(target)
        bucket := routingTable.buckets[bucketIndex]

        candidates.Append(bucket.GetContactAndCalcDistance(target))

        for i := 1; (bucketIndex-i &gt;= 0 || bucketIndex+i &lt; IDLength*8) &amp;&amp; candidates.Len() &lt; count; i++ </span><span class="cov8" title="1">{
                if bucketIndex-i &gt;= 0 </span><span class="cov8" title="1">{
                        bucket = routingTable.buckets[bucketIndex-i]
                        candidates.Append(bucket.GetContactAndCalcDistance(target))
                }</span>
                <span class="cov8" title="1">if bucketIndex+i &lt; IDLength*8 </span><span class="cov8" title="1">{
                        bucket = routingTable.buckets[bucketIndex+i]
                        candidates.Append(bucket.GetContactAndCalcDistance(target))
                }</span>
        }

        <span class="cov8" title="1">candidates.Sort()

        if count &gt; candidates.Len() </span><span class="cov8" title="1">{
                count = candidates.Len()
        }</span>

        <span class="cov8" title="1">return candidates.GetContacts(count)</span>
}

// getBucketIndex get the correct Bucket index for the KademliaID
func (routingTable *RoutingTable) getBucketIndex(id *KademliaID) int <span class="cov8" title="1">{
        distance := id.CalcDistance(routingTable.me.ID)
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt; 8; j++ </span><span class="cov8" title="1">{
                        if (distance[i]&gt;&gt;uint8(7-j))&amp;0x1 != 0 </span><span class="cov8" title="1">{
                                return i*8 + j
                        }</span>
                }
        }

        <span class="cov8" title="1">return IDLength*8 - 1</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
